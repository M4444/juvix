* Backends
** Michelson
*** Setup <<Michelson/Setup>>
*** src
**** Juvix
***** Backends
****** Michelson <<Backends/Michelson>>
- _Relies on_
  + [[Michelson/Compilation]]
  + [[Michelson/Parameterisation]]
  + [[Michelson/Pipeline]]
******* Contract <<Michelson/Contract>>
This module provides a default contract environment
******* Optimisation
- This is a simple optimization strategy which replaces sequences of
  Michelson instructions with equivalent sequences of fewer
  instructions.
  + At the moment nontrivial programs are unlikely to compile to
    the smallest equivalent Michelson instruction sequence,
- but little time has been spent on optimization so far - a high
  degree should be possible; the Haskell typesystem provides very
  strong guarantees.
  + A more interesting / potentially more effective strategy might
    be to search the space of equivalent Michelson programs,
    which at small program sizes using bounded heuristic search
    should be computationally feasible -
    then choose the one with the fewest instructions (or based on
    some other gas-estimation preference function).
- _Relies on_
  + [[Compilation/Types]]
  + [[Library]]
******* Parameterisation <<Michelson/Parameterisation>>
Module that implements the backend parameters for the Michelson backend.
- _Relies on_
  + [[Michelson/Compilation]]
  + [[Compilation/Pretty]]
  + [[Compilation/Types]]
  + [[Michelson/Contract]]
  + [[Instructions]]
  + [[InstructionsEff]]
  + [[Interpret]]
  + [[Untyped]]
  + [[Application]]
  + [[Core/Base/Types]]
  + [[Ann]]
  + [[Core/HR/Pretty]]
  + [[Evaluator]]
  + [[Core/Parameterisation]]
  + [[Core/Pretty]]
  + [[Core/Types]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Library/Usage]]
******* Pipeline <<Michelson/Pipeline>>
- _Relies on_
  + [[Michelson/Compilation]]
  + [[Michelson/Parameterisation]]
  + [[Ann]]
  + [[Library]]
  + [[Feedback]]
  + [[Juvix/Pipeline]]
******* Compilation <<Michelson/Compilation>>
- Entrypoints into compilation from core terms to Michelson terms & contracts.
- _Relies on_
  + [[Compilation/Types]]
  + [[VirtualStack]]
  + [[DSL/Environment]]
  + [[Instructions]]
  + [[InstructionsEff]]
  + [[Untyped]]
  + [[Optimisation]]
  + [[Ann/Types]]
  + [[Library]]
******** Pretty <<Compilation/Pretty>>
- _Relies on_
  + [[Compilation/Types]]
  + [[Core/HR/Pretty]]
  + [[Library]]
  + [[NameSymbol]]
  + [[PrettyPrint]]
******** Types <<Compilation/Types>>
- Types used internally by the Michelson backend.
- _Relies on_
  + [[Application]]
  + [[Ann/Types]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[NameSymbol]]
******** VirtualStack
- Serves as a virtual stack over Michelson
- This stack has a few properties
  + The values on this stack may or may not be on the real
    stack. However for convention this should be largely ignored,
    except when you wish to do an operation like pair
    * This can be fixed in the future
    * Until then, one should filter out the virtual stack items
- We keep virtual items on the ="stack"= as that makes the details
  on whether something is constant propagation or not act
  consistently with each other.
  + After all, what may not be a constant now, may be in the
    future, or vice versa!
- Import with qualified and the name of =VStack=
- _Relies on_
  + [[Compilation/Types]]
  + [[Instructions]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Library/Usage]]
******* DSL
******** Contract <<DSL/Contract>>
- _Relies on_
  + [[Library]]
******** Environment <<DSL/Environment>>
- _Relies on_
  + [[Compilation/Types]]
  + [[VirtualStack]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
******** Instructions
- This module serves as a lower layer DSL that is just a binding
  over the untyped instruction bindings
- _Relies on_
  + [[Compilation/Types]]
  + [[Untyped]]
  + [[Library]]
******** InstructionsEff
- This module includes a higher level DSL which each instruction
  has a stack effect
  + This is similar to the base LLVM bindings we have.
  + So for example, emitting an =add=, eats two items from the
    virtual stack, and adds an =Instr.Add= instruction to the
    sequence of instructions to execute
- For constant progoation, have a function say take-2 that looks at
  the top two items in the stack and then returns back either if
  they were constants or not and dispatches logic based on that
- _Relies on_
  + [[Compilation/Types]]
  + [[VirtualStack]]
  + [[DSL/Environment]]
  + [[Instructions]]
  + [[Untyped]]
  + [[Utils]]
  + [[Application]]
  + [[Ann]]
  + [[Library]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
******** Interpret
- _Relies on_
  + [[Compilation/Types]]
  + [[DSL/Contract]]
  + [[Library]]
******** Untyped
- _Relies on_
  + [[Library]]
******** Utils
- _Relies on_
  + [[Instructions]]
  + [[Untyped]]
  + [[Library]]
  + [[NameSymbol]]
*** test
**** Main <<Michelson/test/Main>>
- _Relies on_
  + [[Library]]
  + [[Fetch]]
**** Test
***** Golden <<Michelson/test/Test/Golden>>
- _Relies on_
  + [[Backends/Michelson]]
  + [[Ann/Types]]
  + [[Library]]
  + [[Library/Test/Golden]]
  + [[Juvix/Pipeline]]
***** Michelson <<Test/Michelson>>
- _Relies on_
  + [[Michelson/Compilation]]
  + [[Compilation/Types]]
  + [[DSL/Environment]]
  + [[Instructions]]
  + [[Interpret]]
  + [[Untyped]]
  + [[Optimisation]]
  + [[Application]]
  + [[Ann]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
***** Parameterisation <<Test/Parameterisation>>
- _Relies on_
  + [[Compilation/Types]]
  + [[Untyped]]
  + [[Michelson/Parameterisation]]
  + [[Core/Parameterisation]]
***** Pipeline <<Test/Pipeline>>
- _Relies on_
  + [[Backends/Michelson]]
  + [[Michelson/Compilation]]
  + [[Core/Base]]
  + [[Ann]]
  + [[Core/IR]]
  + [[IR/Typechecker]]
  + [[Core/Types]]
  + [[Library]]
  + [[Library/Usage]]
***** VStack
- _Relies on_
  + [[Compilation/Types]]
  + [[VirtualStack]]
  + [[Untyped]]
  + [[Library]]
  + [[Library/Usage]]
** Plonk
*** Setup <<Plonk/Setup>>
*** src
**** Juvix
***** Backends
****** Plonk
- _Relies on_
  + [[Builder]]
  + [[Circuit]]
  + [[Assignment]]
  + [[Plonk/Compiler]]
  + [[Dot]]
  + [[Plonk/IR]]
  + [[Lang]]
  + [[Plonk/Parameterization]]
  + [[Plonk/Pipeline]]
  + [[Plonk/Types]]
******* Builder
- _Relies on_
  + [[Circuit]]
  + [[Plonk/IR]]
  + [[Library]]
******* Compiler <<Plonk/Compiler>>
- _Relies on_
  + [[Builder]]
  + [[Circuit]]
  + [[Plonk/IR]]
  + [[Plonk/Types]]
  + [[Ann/Types]]
  + [[Library]]
  + [[NameSymbol]]
******* Dot
Visualise circuits using Graphviz
- _Relies on_
  + [[Circuit]]
  + [[Library]]
******* IR <<Plonk/IR>>
- _Relies on_
  + [[Circuit]]
  + [[Library]]
******* Lang
Surface language
- _Relies on_
  + [[Builder]]
  + [[Circuit]]
  + [[Plonk/IR]]
  + [[Library]]
******* Parameterization <<Plonk/Parameterization>>
- _Relies on_
  + [[Plonk/Types]]
  + [[Application]]
  + [[Core/Base/Types]]
  + [[Conversion]]
  + [[Prim]]
  + [[Ann/Types]]
  + [[Evaluator]]
  + [[Core/Parameterisation]]
  + [[Core/Types]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Library/Usage]]
******* Pipeline <<Plonk/Pipeline>>
- _Relies on_
  + [[Builder]]
  + [[Circuit]]
  + [[Plonk/Compiler]]
  + [[Dot]]
  + [[Plonk/Parameterization]]
  + [[Plonk/Types]]
  + [[OnlyExts]]
  + [[Ann]]
  + [[Core/IR]]
  + [[Typechecker/Types]]
  + [[Core/Parameterisation]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[Juvix/Pipeline]]
******* Types <<Plonk/Types>>
- _Relies on_
  + [[Application]]
  + [[Ann]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
******* Circuit
- _Relies on_
  + [[Library]]
******** Assignment
- _Relies on_
  + [[Circuit]]
  + [[Library]]
*** test
**** Main <<Plonk/test/Main>>
- _Relies on_
  + [[Library]]
  + [[Fetch]]
**** Test
***** AnnTerm
- _Relies on_
  + [[Plonk]]
  + [[Plonk]]
  + [[Ann]]
  + [[Library]]
  + [[BLS12381]]
  + [[NameSymbol]]
  + [[Library/Usage]]
***** Compiler <<Test/Compiler>>
- _Relies on_
  + [[Plonk]]
  + [[Plonk]]
  + [[Ann]]
  + [[Library]]
  + [[BLS12381]]
  + [[Feedback]]
  + [[Juvix/Pipeline]]
***** Golden <<Plonk/test/Test/Golden>>
- _Relies on_
  + [[Plonk]]
  + [[Ann]]
  + [[HR]]
  + [[Core/IR]]
  + [[Library]]
  + [[BLS12381]]
  + [[Feedback]]
  + [[Library/Test/Golden]]
  + [[Juvix/Pipeline]]
  + [[Juvix/Pipeline]]
***** Example
****** Polynomial
- _Relies on_
  + [[Plonk]]
  + [[Plonk]]
  + [[Ann]]
  + [[Library]]
  + [[BLS12381]]
  + [[Library/Usage]]
** llvm
*** Setup <<llvm/Setup>>
*** src
**** Juvix
***** Backends
****** LLVM
- _Relies on_
  + [[LLVM/Compilation]]
  + [[LLVM/Parameterization]]
  + [[LLVM/Pipeline]]
  + [[Primitive]]
******* Compilation <<LLVM/Compilation>>
- _Relies on_
  + [[Block]]
  + [[Codegen/Closure]]
  + [[Codegen/Types]]
  + [[CString]]
  + [[ClosureConversion]]
  + [[Pass/Types]]
  + [[Primitive]]
  + [[Ann]]
  + [[Library]]
  + [[Feedback]]
  + [[NameSymbol]]
******* Parameterization <<LLVM/Parameterization>>
Parameterization and application of the LLVM backend primitives.
- _Relies on_
  + [[Codegen/Types]]
  + [[Primitive]]
  + [[Core/Base/Types]]
  + [[Evaluator]]
  + [[Core/Parameterisation]]
  + [[Library]]
******* Pipeline <<LLVM/Pipeline>>
The basic connection between the backend and the Juvix pipeline.
- _Relies on_
  + [[LLVM/Compilation]]
  + [[LLVM/Parameterization]]
  + [[Primitive]]
  + [[Ann]]
  + [[Library]]
  + [[Juvix/Pipeline]]
******* Primitive
Representation of LLVM primitives in Juvix.
- _Relies on_
  + [[Application]]
  + [[Core/Parameterisation]]
  + [[Library]]
******* Codegen
******** Block
- Has the code necessary to generate LLVM Code, and gives a small
  DSL in order to effectively do so.
An example of using the library to define an llvm function from
haskell may look like
@
  defineLink :: (Define m, Debug m) => m Operand.Operand
  defineLink = Block.defineFunction Type.void "link" args $
    do
      aux1 <- auxiliary1
      aux2 <- auxiliary2
      node1 <- Block.externf "node_1"
      node2 <- Block.externf "node_1"
      Types.debugLevelOne $ do
        _ <- Block.printCString "Executing Link rule \n" []
        _ <- Block.printCString "Calling Link on \n" []
        Debug.printNodePort node1 aux1
        Debug.printNodePort node2 aux2
      Ops.setPort ("node_1", "port_1") ("node_2", "port_2")
      Types.debugLevelOne $ do
        _ <- Block.printCString "Calling Link on \n" []
        Debug.printNodePort node1 aux2
        Debug.printNodePort node2 aux1
      Ops.setPort ("node_2", "port_2") ("node_1", "port_1")
      Block.retNull
    where
      args =
        [ (nodePointer, "node_1"),
          (numPortsPointer, "port_1"),
          (nodePointer, "node_2"),
          (numPortsPointer, "port_2")
        ]
@
Here we define a function called "link" that takes 4 arguments, and
generates code that will link two nodes together. Since we are
writing an llvm function, we have to `Block.externf` the given
arguments to be able to refer to them in the LLVM code.
Using the code to compile IR terms coming from some abstract
machine looks a bit different, we can see it in this example here
@
  compileLam ty captures arguments body
   | length captures == 0 = do
      let (llvmArgty, llvmRetty) =
            functionTypeLLVM ty
          llvmArgNames =
            fmap (Block.internName . NameSymbol.toSymbol) arguments
          llvmArguments =
            zip llvmArgty llvmArgNames
      -- time to generate unique names
      lamName <- Block.generateUniqueSymbol "lambda"
      Block.defineFunction llvmRetty lamName llvmArguments $
        do
          bod <- compileTerm body
          Block.ret bod
   | otherwise =
      throw @"err" (Types.UnsupportedOperation "closures are not supported")
@
In this example instead of having to `Block.externf` the given
arguments, we can rely on resolution to properly handle
that. However, we can see effective use of the library with the
`Block.generateUniqueSymbol` function and the
`Block.defineFunction` function. The first gives us an unique to
compile again, while the latter setups up the environment to
compile a new top level declaration.
- _Relies on_
  + [[Codegen/Types]]
  + [[CString]]
  + [[CString]]
  + [[Library]]
  + [[HashMap]]
******** Closure <<Codegen/Closure>>
- _Relies on_
  + [[Block]]
  + [[Codegen/Types]]
  + [[Library]]
******** Constants
Module for predefined constants
- _Relies on_
  + [[Library]]
******** Types <<Codegen/Types>>
- _Relies on_
  + [[CString]]
  + [[CString]]
  + [[Shared]]
  + [[Sum]]
  + [[Library]]
  + [[HashMap]]
********* CString
Defines a type for \00 terminated strings
- _Relies on_
  + [[Library]]
  + [[Library]]
********* Shared
Shared between Types and Sum
- _Relies on_
  + [[CString]]
  + [[Library]]
  + [[HashMap]]
********* Sum
Provides a mechanism for defining Sum types
- Has the code to encode a sum type via what is defined by the user or
  what is defined to create the interaction net system.
- _Relies on_
  + [[Constants]]
  + [[Shared]]
  + [[Library]]
  + [[HashMap]]
******* Pass
******** ClosureConversion
- _Relies on_
  + [[Pass/Types]]
  + [[Primitive]]
  + [[Ann]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
******** Types <<Pass/Types>>
- _Relies on_
  + [[Primitive]]
  + [[Ann]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
*** test
**** Main <<llvm/test/Main>>
- _Relies on_
  + [[Library]]
  + [[Fetch]]
**** Test
***** Golden <<llvm/test/Test/Golden>>
- _Relies on_
  + [[LLVM]]
  + [[Core/Base/Types]]
  + [[Ann]]
  + [[HR/Types]]
  + [[Library]]
  + [[Feedback]]
  + [[Library/Test/Golden]]
  + [[Juvix/Pipeline]]
  + [[Juvix/Pipeline]]
***** Parameterization <<Test/Parameterization>>
- _Relies on_
  + [[LLVM/Compilation]]
  + [[LLVM/Parameterization]]
  + [[LLVM/Pipeline]]
  + [[Primitive]]
  + [[Core/Parameterisation]]
* BerlinPipeline
** Setup <<BerlinPipeline/Setup>>
** src
*** Juvix
**** BerlinPipeline
***** CircularList
- _Relies on_
  + [[Library]]
***** Env <<BerlinPipeline/Env>>
- _Relies on_
  + [[CircularList]]
  + [[BerlinPipeline/Pipeline]]
  + [[RecursiveList]]
  + [[Step]]
  + [[Library]]
  + [[NameSymbol]]
***** Meta
- _Relies on_
  + [[Library]]
***** Pipeline <<BerlinPipeline/Pipeline>>
- _Relies on_
  + [[Meta]]
  + [[Juvix/Context]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
***** RecursiveList
A Recursive list represents the concept of a list with a chance to nest.
This allows us to get a tree like structure, where a pipeline step can contain more steps.
- _Relies on_
  + [[Library]]
***** Step
- _Relies on_
  + [[Meta]]
  + [[BerlinPipeline/Pipeline]]
  + [[Library]]
  + [[NameSymbol]]
** test
*** Main <<BerlinPipeline/test/Main>>
- _Relies on_
  + [[Library]]
  + [[Fetch]]
* Context
** Setup <<Context/Setup>>
** src
*** Juvix
**** Closure <<Juvix/Closure>>
Closure.T serves as the data structure in which we will store
temporary lexical bindings as our code encounters binders.
- _Relies on_
  + [[Juvix/Context]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
***** Abstract
Closure.T serves as the data structure in which we will store
temporary lexical bindings as our code encounters binders.
- _Relies on_
  + [[Juvix/Context]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
**** Context <<Juvix/Context>>
- Serves as the context for lower level programs of the =Juvix=
  Programming Language
- This is parameterized per phase which may store the type and
  term in slightly different ways
- _Relies on_
  + [[NameSpace]]
  + [[Precedence]]
  + [[Context/Types]]
  + [[Library]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
***** NameSpace
- _Relies on_
  + [[Library]]
  + [[HashMap]]
***** Open
- _Relies on_
  + [[Library]]
***** Precedence
- _Relies on_
  + [[Library]]
***** Traversal
Traversals serves as generic Context Traversal modules.
- _Relies on_
  + [[Juvix/Context]]
  + [[NameSpace]]
  + [[Context/Types]]
  + [[Library]]
  + [[HashMap]]
***** Types <<Context/Types>>
- _Relies on_
  + [[NameSpace]]
  + [[Open]]
  + [[Precedence]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Library/Usage]]
** test
*** Context <<test/Context>>
- _Relies on_
  + [[Juvix/Context]]
  + [[NameSpace]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
*** Main <<Context/test/Main>>
- _Relies on_
  + [[Fetch]]
* Core
** Setup <<Core/Setup>>
** src
*** Juvix
**** Core
***** Application
Types to support partial application and polymorphic primitives.
- _Relies on_
  + [[Core/Base/Types]]
  + [[IR/Types]]
  + [[Core/Pretty]]
  + [[Library]]
  + [[Library/Usage]]
***** Parameterisation <<Core/Parameterisation>>
Juvix parameterises the type theory & core language over a set of
primitive data types and primitive values, which can include native data
types such as strings, integers, or sets, and native functions such as
addition, subtraction, string concatenation, set membership, etc. The
language & typechecker can then be instantiated over a particular backend
which provides concrete sets of primitives and a primitive type-checking
relation.
- _Relies on_
  + [[Application]]
  + [[Core/Base/Types]]
  + [[IR/Types]]
  + [[Core/Pretty]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Library/Usage]]
***** Pretty <<Core/Pretty>>
- _Relies on_
  + [[Core/Base]]
  + [[Library]]
  + [[NameSymbol]]
  + [[PrettyPrint]]
  + [[PrettyPrint]]
  + [[Library/Usage]]
***** Translate <<Core/Translate>>
- _Relies on_
  + [[Core/Base/Types]]
  + [[HR/Types]]
  + [[IR/Types]]
  + [[Core/Utility]]
  + [[Library]]
  + [[NameSymbol]]
***** Types <<Core/Types>>
- _Relies on_
  + [[Erased]]
  + [[Algorithm/Types]]
  + [[Core/HR/Pretty]]
  + [[HR/Types]]
  + [[IR/Typechecker]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[PrettyPrint]]
***** Utility <<Core/Utility>>
Provides utility and functionality for automatic pattern names,
name streams, and aliases for capabilities over these structures.
- Streams are offered in this module for an infinite name supply
  structures
- Operations are given for shuffling these in a capability
- Pattern Variables are given to help set the mapping between
  patterns and symbols
- =HasNamStack= talks about the mapping between names in the =HR=
  form and the =De Brunjin= Index
- _Relies on_
  + [[Core/Base/Types]]
  + [[Library]]
  + [[NameSymbol]]
***** Base <<Core/Base>>
- _Relies on_
  + [[Core/Base/Types]]
****** TransformExt
Transformations between different extensions.
- _Relies on_
  + [[Core/Base/Types]]
  + [[Library]]
******* OnlyExts
A transformation that discards all annotations on term/elim nodes, but
keeps the extensions.
- _Relies on_
  + [[TransformExt]]
  + [[Core/Base/Types]]
  + [[Library]]
****** Types <<Core/Base/Types>>
- _Relies on_
  + [[Base/Types/Base]]
  + [[Globals]]
  + [[Types/Sig]]
******* Base <<Base/Types/Base>>
- _Relies on_
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
******* Globals
- _Relies on_
  + [[Base/Types/Base]]
  + [[Library]]
  + [[HashMap]]
  + [[Library/Usage]]
******* Sig <<Types/Sig>>
- _Relies on_
  + [[Base/Types/Base]]
  + [[Library]]
  + [[NameSymbol]]
***** Erased
- _Relies on_
  + [[Erased/Types]]
  + [[Util]]
****** Types <<Erased/Types>>
- _Relies on_
  + [[Erased/Base/Types]]
  + [[Typechecker/Types]]
  + [[Library]]
****** Util
- _Relies on_
  + [[Erased/Types]]
  + [[Library]]
  + [[NameSymbol]]
****** Algorithm
- _Relies on_
  + [[Core/Base/Types]]
  + [[Algorithm/Types]]
  + [[Core/IR]]
  + [[Typechecker/Types]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
******* Types <<Algorithm/Types>>
- _Relies on_
  + [[Core/Base]]
  + [[TransformExt]]
  + [[Core/Base/Types]]
  + [[Erased/Base/Types]]
  + [[Erased/Types]]
  + [[Erased/Types]]
  + [[Core/HR/Pretty]]
  + [[HR/Types]]
  + [[Core/IR]]
  + [[Typechecker/Types]]
  + [[Core/Parameterisation]]
  + [[Core/Translate]]
  + [[Library]]
  + [[NameSymbol]]
  + [[PrettyPrint]]
  + [[Library/Usage]]
****** Ann
- _Relies on_
  + [[Conversion]]
  + [[Ann/Pretty]]
  + [[Prim]]
  + [[Ann/Types]]
******* Conversion
- _Relies on_
  + [[Application]]
  + [[Core/Base]]
  + [[OnlyExts]]
  + [[Erased]]
  + [[Algorithm]]
  + [[Algorithm/Types]]
  + [[Prim]]
  + [[Ann/Types]]
  + [[Ann/Types]]
  + [[Core/IR]]
  + [[Evaluator]]
  + [[IR/Typechecker]]
  + [[IR/Typechecker]]
  + [[Core/Types]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
******* Erasure <<Ann/Erasure>>
- _Relies on_
  + [[Ann/Types]]
  + [[Ann/Types]]
  + [[Erased/Types]]
  + [[Library]]
******* Pretty <<Ann/Pretty>>
- _Relies on_
  + [[Ann/Types]]
  + [[Core/HR/Pretty]]
  + [[Core/HR/Pretty]]
  + [[Library]]
  + [[PrettyPrint]]
******* Prim
- _Relies on_
  + [[Application]]
  + [[Ann/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[Library/Usage]]
******* Types <<Ann/Types>>
- _Relies on_
  + [[Application]]
  + [[Core/Base/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
****** Base
******* Types <<Erased/Base/Types>>
- _Relies on_
  + [[Core/Base/Types]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Library/Usage]]
***** HR
- _Relies on_
  + [[Core/HR/Pretty]]
  + [[HR/Types]]
****** Extend
- _Relies on_
  + [[Core/Base/Types]]
  + [[Library]]
  + [[NameSymbol]]
****** Pretty <<Core/HR/Pretty>>
- _Relies on_
  + [[HR/Types]]
  + [[Core/Pretty]]
  + [[Library]]
  + [[NameSymbol]]
****** Sexp <<HR/Sexp>>
- _Relies on_
  + [[Base/Types/Base]]
  + [[HR/Types]]
  + [[Library]]
  + [[Library/Usage]]
  + [[Juvix/Sexp]]
  + [[Structure]]
  + [[CoreNamed]]
  + [[Lens]]
****** Types <<HR/Types>>
- _Relies on_
  + [[Application]]
  + [[Core/Base/Types]]
  + [[Extend]]
  + [[Library]]
  + [[NameSymbol]]
***** IR <<Core/IR>>
- _Relies on_
  + [[CheckTerm]]
  + [[Evaluator]]
  + [[IR/Typechecker]]
  + [[IR/Types]]
  + [[Library]]
****** CheckDatatype
Datatype declarations are typechecked here. Usages are passed along.
- _Relies on_
  + [[OnlyExts]]
  + [[Core/Base/Types]]
  + [[CheckTerm]]
  + [[Evaluator]]
  + [[Typechecker/Env]]
  + [[Error]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
****** CheckTerm
This file contains the functions and aux functions to typecheck terms.
@typeTerm@ and @typeElim@ are called by functions for typechecking
datatype and function declarations.
- _Relies on_
  + [[Application]]
  + [[OnlyExts]]
  + [[Core/Base/Types]]
  + [[Evaluator]]
  + [[Typechecker/Env]]
  + [[Error]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[Library/Usage]]
****** Types <<IR/Types>>
Quantitative type implementation inspired by
  Atkey 2018 and McBride 2016.
- _Relies on_
  + [[Core/Base/Types]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
****** Evaluator
This includes the evaluators (`evalTerm` and `evalElim`),
the value application function (`vapp`) and
the substitution functions (`substV`).
- _Relies on_
  + [[TransformExt]]
  + [[TransformExt]]
  + [[OnlyExts]]
  + [[Core/Base/Types]]
  + [[PatSubst]]
  + [[SubstV]]
  + [[Evaluator/Types]]
  + [[Evaluator/Weak]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
******* PatSubst
Provides the `HasPatSubst`-class for pattern substitution.
- _Relies on_
  + [[Application]]
  + [[OnlyExts]]
  + [[Core/Base/Types]]
  + [[Evaluator/Weak]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[Library/Usage]]
******* SubstV
Module providing the `HasSubstV`-class, implementing substitution of
values.
- _Relies on_
  + [[Application]]
  + [[Core/Base/Types]]
  + [[Evaluator/Types]]
  + [[Evaluator/Weak]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[Library/Usage]]
******* Types <<Evaluator/Types>>
The types as used by the evaluator.
- _Relies on_
  + [[Core/Base/Types]]
  + [[Core/HR/Pretty]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Core/Translate]]
  + [[Library]]
  + [[PrettyPrint]]
******* Weak <<Evaluator/Weak>>
Provides weakening / shifting of de Bruijn indices, that is the
renumbering of free variables in terms.
- _Relies on_
  + [[Application]]
  + [[Core/Base/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[Library/Usage]]
****** Typechecker <<IR/Typechecker>>
This file contains the functions and aux functions to typecheck
datatype and function declarations.
Datatype declarations are typechecked by @checkDataType@ in CheckDataType.hs.
Terms are typechecked by @typeTerm@ in CheckTerm.hs.
Typechecked declarations are added to the signature.
- _Relies on_
  + [[OnlyExts]]
  + [[Core/Base/Types]]
  + [[CheckDatatype]]
  + [[CheckTerm]]
  + [[Evaluator]]
  + [[Typechecker/Env]]
  + [[Error]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
******* Env <<Typechecker/Env>>
- _Relies on_
  + [[OnlyExts]]
  + [[Core/Base/Types]]
  + [[Evaluator]]
  + [[Error]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[Library/Usage]]
******* Error
- _Relies on_
  + [[Core/Base/Types]]
  + [[Core/HR/Pretty]]
  + [[Evaluator]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Core/Translate]]
  + [[Library]]
  + [[PrettyPrint]]
  + [[Library/Usage]]
******* Types <<Typechecker/Types>>
- _Relies on_
  + [[Application]]
  + [[Core/Base/Types]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[Library/Usage]]
***** Parameterisations
****** All
- _Relies on_
  + [[Application]]
  + [[Core/Base/Types]]
  + [[Evaluator]]
  + [[Core/Parameterisation]]
  + [[Naturals]]
  + [[Unit]]
  + [[Library]]
****** Naturals
- _Relies on_
  + [[Application]]
  + [[Core/Base/Types]]
  + [[Core/HR/Pretty]]
  + [[Evaluator]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[PrettyPrint]]
****** Unit
- _Relies on_
  + [[Core/Base/Types]]
  + [[Evaluator]]
  + [[Core/Parameterisation]]
  + [[Library]]
***** Pipeline
****** ToIR <<Core/Pipeline/ToIR>>
- _Relies on_
  + [[Core/Base/Types]]
  + [[HR]]
  + [[Core/IR]]
  + [[Core/Translate]]
  + [[Core/Translate]]
  + [[Library]]
** test
*** Conv
- _Relies on_
  + [[Core/Base]]
  + [[HR]]
  + [[Core/IR]]
  + [[Core/Translate]]
  + [[Library]]
*** Erasure <<test/Erasure>>
- _Relies on_
  + [[Application]]
  + [[Core/Base]]
  + [[Erased]]
  + [[Algorithm]]
  + [[Core/IR]]
  + [[IR/Typechecker]]
  + [[Core/Parameterisation]]
  + [[Unit]]
  + [[Core/Types]]
  + [[Library]]
  + [[Library/Usage]]
*** Main <<Core/test/Main>>
- _Relies on_
  + [[Library]]
  + [[Fetch]]
*** Typechecker <<test/Typechecker>>
Tests for the type checker and evaluator in Core/IR/Typechecker.hs
- _Relies on_
  + [[Application]]
  + [[Core/Base]]
  + [[Core/Base]]
  + [[OnlyExts]]
  + [[Core/IR]]
  + [[CheckTerm]]
  + [[Evaluator]]
  + [[IR/Typechecker]]
  + [[Core/Parameterisation]]
  + [[All]]
  + [[Naturals]]
  + [[Unit]]
  + [[Core/Types]]
  + [[Library]]
  + [[HashMap]]
  + [[Library/Usage]]
*** Utility <<test/Utility>>
- _Relies on_
  + [[Core/Utility]]
*** HR
**** Pretty <<test/HR/Pretty>>
- _Relies on_
  + [[Core/Base]]
  + [[HR]]
  + [[Naturals]]
  + [[Library]]
  + [[NameSymbol]]
  + [[PrettyPrint]]
  + [[Library/Usage]]
**** Serialize <<HR/Serialize>>
- _Relies on_
  + [[HR]]
  + [[HR/Sexp]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
  + [[Juvix/Sexp]]
*** IR
**** Weak <<IR/Weak>>
Tests that weak works as expected
- _Relies on_
  + [[Evaluator]]
  + [[IR/Types]]
  + [[Library]]
* Parsing
** Setup <<Parsing/Setup>>
** src
*** Juvix
**** Parsing <<Juvix/Parsing>>
- _Relies on_
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Parser]]
  + [[Parsing/Parser]]
  + [[Parsing/Types]]
***** Parser <<Parsing/Parser>>
Module      : Parser
Description : The Juvix frontend parser
In order to be able to understand this code, we suggest reading about
how parser combinators work. [Here](https://hasura.io/blog/parser-combinators-walkthrough/)'s a wonderful introduction.
== The infix operator
@
  expressionGen :: Parser Types.Expression -> Parser Types.Expression
  expressionGen p =
    Expr.makeExprParser (spaceLiner (expressionGen' p)) tableExp
  -- For Expressions
  tableExp :: [[Expr.Operator Parser Types.Expression]]
  tableExp =
    [ [refine],
      [infixOp],
      [arrowExp]
    ]
  infixOp :: Expr.Operator Parser Types.Expression
  infixOp =
    Expr.InfixR
      ( P.try $ do
          inf <- spaceLiner infixSymbolDot
          pure
            (\l r -> Types.Infix (Types.Inf l inf r))
      )
@
Here we outline three key functions:
- _Relies on_
  + [[Library]]
  + [[Library/Parser]]
  + [[Library/Parser]]
  + [[Parsing/Types]]
****** The `expressionGen` uses the `tableExp` as the precedence table of infix parsers. So `refine` has a higher precedence than `infixOp`. At the end of `expressionGen` we get back a new parser for any expression parser we may hand it.
****** The `infixOp` structure explicitly states what kind of infix it is, in our case we make it nest on the right, so `a -> b -> c` gets turned into `a -> (b -> c)`. The important thing to note is that we only parse for the inifix symbol itself, we let the parser we hand to `expressionGen` handle the other side.
Every other tool you'll see is an abstraction on top of these base
tools. Even the infix handler is built upon the first two primitives
we've outlined.
== Juvix's custom parser combinators
We use parser combinators mostly in the standard way, however you'll often see the forms `skipLiner`, `spaceLiner`, and the convention `*SN` which are not typical in a parser combinator system.
****** `spaceLiner` just eats all empty symbols, these are spaces and
newlines after the current parsed expression.
****** `skipLiner` is the same as `spaceLiner`, but it is for any character given to it.
****** Finally `*SN` just calls `spaceLiner` on whatever parser. E.g.
@
sumSN :: Parser Types.Sum
sumSN = spaceLiner sum
@
In short, parsers with S at the end, eat the spaces at the end of the parse.
Parsers with SN at the end, eats the spaces and new lines at the end of the parse
Note that these concepts exist namely due to the wish of eventually making the
parser indent sensitive.
The main confusing bit of our layout is the many variants of
expression:
@
  do''' :: Parser Types.Expression
  do''' = Types.Do <$> do'
  app'' :: Parser Types.Expression
  app'' = Types.Application <$> P.try application
  all'' :: Parser Types.Expression
  all'' = P.try do''' <|> app''
  -- used to remove do from parsing
  expression' :: Parser Types.Expression
  expression' = expressionGen app''
  -- used to remove both from parsing
  expression''' :: Parser Types.Expression
  expression''' = expressionGen (fail "")
  expression :: Parser Types.Expression
  expression = expressionGen all''
@
We have three main variants, ones with application, ones with do
syntax, and ones with both! These exists because certain
transformations will go into an infinite loop if you're not
careful. This is mainly due to how some forms like `do` and infix
generators behave together. In other cases like in adt declarations,
we want to disable application `type List a = Cons a (List a)`. It
would be a shame if the `a` was applied to `List a`!
***** Types <<Parsing/Types>>
- This file defines the main ADT for the Juvix front end language.
- This ADT corresponds to the BNF laid out [[https://juvix.readthedocs.io/en/latest/compiler/frontend/s-expression-syntax.html#bnf-syntax][here]].
- Later a trees that grow version of this will be implemented, so
  infix functions can better transition across syntax
- Note :: The names for the types in =ArrowData= are stored in the
          =ArrowGen= and not in =NamedType=
- _Relies on_
  + [[Parsing/Types/Base]]
****** Base <<Parsing/Types/Base>>
- _Relies on_
  + [[Library]]
  + [[Library/Usage]]
****** Located
- _Relies on_
  + [[Library]]
  + [[Library/Parser]]
** test
*** Main <<Parsing/test/Main>>
- _Relies on_
  + [[Library]]
  + [[Fetch]]
*** Parser <<test/Parser>>
- _Relies on_
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Parser]]
  + [[Library/Parser]]
  + [[Parsing/Parser]]
  + [[Parsing/Types]]
  + [[Parsing/Types]]
* Pipeline
** Setup <<Pipeline/Setup>>
** src
*** Juvix
**** Pipeline <<Juvix/Pipeline>>
- _Relies on_
  + [[Juvix/Context]]
  + [[Application]]
  + [[Core/Base]]
  + [[TransformExt]]
  + [[OnlyExts]]
  + [[Ann]]
  + [[HR/Types]]
  + [[Core/IR]]
  + [[Typechecker/Types]]
  + [[Core/Parameterisation]]
  + [[Core/Parameterisation]]
  + [[Core/Translate]]
  + [[Core/Types]]
  + [[Library]]
  + [[Feedback]]
  + [[NameSymbol]]
  + [[Library/Parser]]
  + [[Library/Usage]]
  + [[Juvix/Parsing]]
  + [[Parsing/Types]]
  + [[Compile]]
  + [[ToHR]]
  + [[Juvix/Pipeline/ToIR]]
  + [[Pipeline/ToSexp]]
  + [[Pipeline/Types]]
  + [[Juvix/Sexp]]
***** Compile
- _Relies on_
  + [[Application]]
  + [[Core/Base]]
  + [[Core/IR]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[Feedback]]
  + [[Def]]
  + [[ToHR/Types]]
***** ToIR <<Juvix/Pipeline/ToIR>>
- _Relies on_
  + [[Core/Pipeline/ToIR]]
***** ToSexp <<Pipeline/ToSexp>>
- _Relies on_
  + [[Juvix/Context]]
  + [[Juvix/Contextify]]
  + [[Algorithm]]
  + [[Core/HR/Pretty]]
  + [[Core/Translate]]
  + [[Core/Types]]
  + [[Desugar]]
  + [[Library]]
  + [[NameSymbol]]
  + [[PrettyPrint]]
  + [[Parsing/Types]]
  + [[Juvix/Sexp]]
  + [[Translate/Pipeline]]
***** Types <<Pipeline/Types>>
- _Relies on_
  + [[Algorithm/Types]]
  + [[Ann/Types]]
  + [[Core/IR]]
  + [[Typechecker/Types]]
  + [[Core/Types]]
  + [[Library]]
***** ToHR
- _Relies on_
  + [[Juvix/Closure]]
  + [[Juvix/Context]]
  + [[Traversal]]
  + [[Core/Base]]
  + [[Traverse]]
  + [[HR]]
  + [[Core/IR]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Parser]]
  + [[Library/Usage]]
  + [[Juvix/Parsing]]
  + [[Def]]
  + [[ToHR/Env]]
  + [[ToHR/Sig]]
  + [[ToHR/Types]]
  + [[Juvix/Sexp]]
****** Def
- _Relies on_
  + [[Juvix/Closure]]
  + [[Juvix/Context]]
  + [[Core/Base]]
  + [[Core/Base/Types]]
  + [[HR]]
  + [[HR]]
  + [[Library]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
  + [[ToHR/Env]]
  + [[Extract]]
  + [[Term]]
  + [[ToHR/Types]]
  + [[Juvix/Sexp]]
****** Env <<ToHR/Env>>
- _Relies on_
  + [[Juvix/Closure]]
  + [[Juvix/Context]]
  + [[Core/Base/Types]]
  + [[HR]]
  + [[Core/IR]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[ToHR/Types]]
  + [[Juvix/Sexp]]
****** Term
- _Relies on_
  + [[Juvix/Closure]]
  + [[Core/Base]]
  + [[HR]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
  + [[ToHR/Env]]
  + [[Extract]]
  + [[ToHR/Types]]
  + [[ToHR/Usage]]
  + [[Juvix/Sexp]]
****** TypeSig
- _Relies on_
  + [[Core/Base]]
  + [[HR]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
  + [[ToHR/Env]]
  + [[Term]]
  + [[ToHR/Types]]
  + [[Juvix/Sexp]]
  + [[Structure/Parsing]]
****** Types <<ToHR/Types>>
- _Relies on_
  + [[Juvix/Context]]
  + [[Core/Base]]
  + [[HR]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
  + [[Juvix/Sexp]]
****** Usage <<ToHR/Usage>>
- _Relies on_
  + [[Core/Base]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
  + [[ToHR/Env]]
  + [[Extract]]
  + [[ToHR/Types]]
  + [[Juvix/Sexp]]
****** Sig <<ToHR/Sig>>
- _Relies on_
  + [[Juvix/Context]]
  + [[Core/Base/Types]]
  + [[HR]]
  + [[Library]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Usage]]
  + [[ToHR/Env]]
  + [[Extract]]
  + [[Term]]
  + [[TypeSig]]
  + [[ToHR/Types]]
  + [[ToHR/Usage]]
  + [[Juvix/Sexp]]
******* Extract
- _Relies on_
  + [[Juvix/Closure]]
  + [[Juvix/Context]]
  + [[Core/Base/Types]]
  + [[HR]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Library/Usage]]
  + [[ToHR/Env]]
  + [[ToHR/Types]]
  + [[Juvix/Sexp]]
** test
*** Main <<Pipeline/test/Main>>
- _Relies on_
  + [[Library]]
  + [[Fetch]]
*** Test
**** RecGroups
- _Relies on_
  + [[Juvix/Context]]
  + [[Traverse]]
  + [[Library]]
  + [[Juvix/Parsing]]
  + [[Juvix/Pipeline]]
  + [[Pipeline/ToSexp]]
  + [[Juvix/Sexp]]
**** ToSexp <<Test/ToSexp>>
- _Relies on_
  + [[Desugar]]
  + [[Library]]
  + [[Parsing/Parser]]
  + [[Parsing/Types]]
  + [[Pipeline/ToSexp]]
  + [[Juvix/Sexp]]
* Playground
** Easy
*** Setup <<Easy/Setup>>
*** src
**** Easy
The easy module serves as the stop shop for getting anywhere in the
code-base fast.
_The file is laid out where_
 1. we lay out a phase
    - We have 2 variants of each phase
      1) <name>File
      2) <name>Library
    - This lasts up until context, as we can see if the prelude we
      give it matches our expectations
 2. We then give examples
We do 1. and 2. having each step rely on the last, and continue the
process until the compiler is at the full backends.
We can view this approach as giving us a quick way to play around
with any stage of the compiler while modifying the source code.
- _Relies on_
  + [[LLVM/Parameterization]]
  + [[LLVM/Pipeline]]
  + [[Primitive]]
  + [[Michelson/Parameterisation]]
  + [[Michelson/Pipeline]]
  + [[Plonk]]
  + [[Juvix/Context]]
  + [[NameSpace]]
  + [[Juvix/Contextify]]
  + [[ResolveOpenInfo]]
  + [[ToContext/Types]]
  + [[Core/Base]]
  + [[TransformExt]]
  + [[OnlyExts]]
  + [[Traverse]]
  + [[Ann]]
  + [[Core/IR]]
  + [[Core/Parameterisation]]
  + [[Core/Types]]
  + [[Desugar]]
  + [[Library]]
  + [[BLS12381]]
  + [[Feedback]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Library/Usage]]
  + [[Juvix/Parsing]]
  + [[Parsing/Parser]]
  + [[Parsing/Types]]
  + [[Parsing/Types]]
  + [[Parsing/Types/Base]]
  + [[Juvix/Pipeline]]
  + [[Compile]]
  + [[ToHR]]
  + [[Juvix/Pipeline/ToIR]]
  + [[Juvix/Sexp]]
  + [[TopLevel]]
*** test
**** FromFrontend
- _Relies on_
  + [[Core/Base/Types]]
  + [[IR/Types]]
  + [[Library]]
**** Spec <<Easy/test/Spec>>
- _Relies on_
  + [[Library]]
  + [[Fetch]]
** HTTP
*** Setup <<HTTP/Setup>>
*** src
**** Main <<src/Main>>
- _Relies on_
  + [[Library]]
  + [[API]]
**** Juvix
***** Playground
****** HTTP
******* API
- _Relies on_
  + [[Library]]
  + [[Routes]]
******* Routes
- _Relies on_
  + [[LLVM]]
  + [[Backends/Michelson]]
  + [[Plonk]]
  + [[Juvix/Context]]
  + [[Core/Base]]
  + [[Core/Base]]
  + [[OnlyExts]]
  + [[Ann]]
  + [[HR]]
  + [[Core/IR]]
  + [[Typechecker/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
  + [[BLS12381]]
  + [[Feedback]]
  + [[NameSymbol]]
  + [[Parsing/Types]]
  + [[Juvix/Pipeline]]
  + [[Juvix/Sexp]]
*** test
**** Main <<HTTP/test/Main>>
- _Relies on_
  + [[Library]]
  + [[Fetch]]
* Sexp
** Setup <<Sexp/Setup>>
** src
*** Juvix
**** Sexp <<Juvix/Sexp>>
This module serves as the main sexpression import it contains the
sexp type and all the various helper functionality one can need.
The star affix stands for a play on a theme. In this case the theme
is that they recurse on the structure itself calling itself on very
nested structures.
- _Relies on_
  + [[Library]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp/Parser]]
  + [[Juvix/Sexp/Serialize]]
  + [[Sexp/Types]]
***** Parser <<Juvix/Sexp/Parser>>
- _Relies on_
  + [[Library]]
  + [[NameSymbol]]
  + [[Library/Parser]]
  + [[Internal]]
  + [[Token]]
  + [[Sexp/Types]]
***** Serialize <<Juvix/Sexp/Serialize>>
- _Relies on_
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Sexp/Types]]
***** Types <<Sexp/Types>>
- _Relies on_
  + [[Library]]
  + [[LineNum]]
  + [[NameSymbol]]
***** Structure
- _Relies on_
  + [[Library]]
  + [[Juvix/Sexp]]
****** CoreNamed
Hardening S-expressions into a more readable form. Here we use a
mixture of record structures and aliases. Each cover a form that we
wish to talk about rather than just match away at
- _The form for transformation follows this structure_
#+begin_src haskell
  -- the data type
  data Form = ... deriving (Show)
  is<Form>   :: Sexp.T -> Bool
  to<Form>   :: Sexp.T -> Maybe <Form>
  from<Form> :: <Form> -> Sexp.T
#+end_src
+ With the following properties of the forms
  #+begin_src haskell
    ∀ s : Sexp.T. is<Form> s = True ⟷ is-just (to<Form> s)
    to<Form> 。 from<Form> = Just
  #+end_src
_TODO_
 1. Figure out if we can even express a spec system in
    Haskell... =to<Form>= and =From<From>= have the exact same signature
 2. replace the repeat code with the =to<Form>= with an abstraction
 3. put the meta data with the form so we don't have to do it by
    hand in the code that uses this
    1. Use =Juvix.Library.LineNum=
    2. append the =Form= With this
    3. have to<Form> fill this
    4. Have extra smart consturctors that are =<form>=, so that we
       can automatically fill in this meta data
- _Relies on_
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
  + [[Structure]]
  + [[Structure/Helpers]]
****** Helpers <<Structure/Helpers>>
- _Relies on_
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
****** Lens
- _Relies on_
  + [[CoreNamed]]
  + [[Structure/Parsing]]
  + [[Transition]]
****** Parsing <<Structure/Parsing>>
Hardening S-expressions into a more readable form. Here we use a
mixture of record structures and aliases. Each cover a form that we
wish to talk about rather than just match away at
- _The form for transformation follows this structure_
#+begin_src haskell
  -- the data type
  data Form = ... deriving (Show)
  is<Form>   :: Sexp.T -> Bool
  to<Form>   :: Sexp.T -> Maybe <Form>
  from<Form> :: <Form> -> Sexp.T
#+end_src
+ With the following properties of the forms
  #+begin_src haskell
    ∀ s : Sexp.T. is<Form> s = True ⟷ is-just (to<Form> s)
    to<Form> 。 from<Form> = Just
  #+end_src
_TODO_
 1. Figure out if we can even express a spec system in
    Haskell... =to<Form>= and =From<From>= have the exact same signature
 2. replace the repeat code with the =to<Form>= with an abstraction
 3. put the meta data with the form so we don't have to do it by
    hand in the code that uses this
    1. Use =Juvix.Library.LineNum=
    2. append the =Form= With this
    3. have to<Form> fill this
    4. Have extra smart consturctors that are =<form>=, so that we
       can automatically fill in this meta data
- _Relies on_
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
  + [[Structure]]
  + [[Structure/Helpers]]
****** Transition
Hardening S-expressions into a more readable form. Here we use a
mixture of record structures and aliases. Each cover a form that we
wish to talk about rather than just match away at
- _The form for transformation follows this structure_
#+begin_src haskell
  -- the data type
  data Form = ... deriving (Show)
  is<Form>   :: Sexp.T -> Bool
  to<Form>   :: Sexp.T -> Maybe <Form>
  from<Form> :: <Form> -> Sexp.T
#+end_src
+ With the following properties of the forms
  #+begin_src haskell
    ∀ s : Sexp.T. is<Form> s = True ⟷ is-just (to<Form> s)
    to<Form> 。 from<Form> = Just
  #+end_src
_TODO_
 1. Figure out if we can even express a spec system in
    Haskell... =to<Form>= and =From<From>= have the exact same signature
 2. replace the repeat code with the =to<Form>= with an abstraction
 3. put the meta data with the form so we don't have to do it by
    hand in the code that uses this
    1. Use =Juvix.Library.LineNum=
    2. append the =Form= With this
    3. have to<Form> fill this
    4. Have extra smart consturctors that are =<form>=, so that we
       can automatically fill in this meta data
- _Relies on_
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
  + [[Structure]]
  + [[Structure/Helpers]]
  + [[Structure/Parsing]]
  + [[Structure/Parsing]]
** test
*** Main <<Sexp/test/Main>>
- _Relies on_
  + [[Library]]
  + [[Fetch]]
*** Sexp <<test/Sexp>>
- _Relies on_
  + [[Library]]
  + [[Juvix/Sexp]]
**** Parser <<test/Sexp/Parser>>
- _Relies on_
  + [[Library]]
  + [[Juvix/Sexp]]
**** Serialize <<test/Sexp/Serialize>>
- _Relies on_
  + [[Library]]
  + [[HashMap]]
  + [[Juvix/Sexp]]
**** SimplifiedPasses
- _Relies on_
  + [[Library]]
  + [[Juvix/Sexp]]
* StandardLibrary
** Setup <<StandardLibrary/Setup>>
** app
*** Main <<app/Main>>
- _Relies on_
  + [[Library]]
  + [[Fetch]]
** src
*** Juvix
**** Library
- The standard Library for the project
  + Thus all code will depend on this module without stating otherwise
- Is mostly =Protolude= except with a few changes
  + _Additions_
    * ∨   :: Serves as an or function
    * ∧   :: Serves as an and function
    * |<< :: Serves as a map function
    * >>| :: Serves as the flip map function
  + _Changes_
    * The Capability library is imported and replaces the standard =MTL=
      constructs in =Protolude=
***** BLS12381
- _Relies on_
  + [[Library]]
***** Feedback
- _Relies on_
  + [[Library]]
***** Fetch
***** HashMap
- The HashMap for the codebase.
- Basically just imports Data.HashMap.Strict
  + While giving the operation =!?=.
- Every hash in the code base should use this, except when it needs
  to compare keys by the =Ordering= metric instead.
***** LineNum
- _Relies on_
  + [[Library]]
***** NameSymbol
- _Relies on_
  + [[Library]]
  + [[Token]]
  + [[PrettyPrint]]
***** PrettyPrint
- _Relies on_
  + [[Library]]
***** Usage <<Library/Usage>>
Each binder and local context element in Juvix is annotated with
a /usage/, which tracks how many times it is needed in a
runtime-relevant way.
- _Relies on_
  + [[Library]]
  + [[PrettyPrint]]
***** Parser <<Library/Parser>>
- _Relies on_
  + [[Internal]]
  + [[Lexer]]
  + [[Token]]
****** Internal
****** Lexer
- _Relies on_
  + [[Library]]
  + [[Internal]]
  + [[Token]]
****** Token
- _Relies on_
  + [[Library]]
***** Test
****** Golden <<Library/Test/Golden>>
@Juvix.Library.Test.Golden@ defines testing functionality for golden
  style tests
- Golden tests revolve around testing files we have saved on
  disk. Namely we wish to take that file and do some transformation
  and save the result to compare it for regression testing.
- There are many useful sub components of this module
- The =Compact= tag to a few of the functions represents golden
  test functions that display the results in different ways. Often
  we use the =Compact= variant for S-expression showing as it's
  much clearer to see what the expressions mean.
- _Relies on_
  + [[Library]]
  + [[Feedback]]
******* NoQuotes
This structure allows us to have golden tests that are based around
show instances instead of normal read instances.
***** Trace <<Library/Trace>>
The Trace library represents the ability to properly trace code
throughout Haskell.
- The structure requires your code to exist in the =Trace.Eff=
  effect.
- The =Eff= Variant of functions are over the =Trace.Eff= effect
  rather than the =Trace.T= type itself.
  + It is just as valid to use the non =Eff= version of the
    functions
- _Relies on_
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Format]]
  + [[Trace/Types]]
  + [[Trace/Types]]
****** Environment <<Trace/Environment>>
This module gives a minimal environment to run Traces, best used
for testing
- _Relies on_
  + [[Library]]
  + [[Trace/Types]]
****** Format
- _Relies on_
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Trace/Types]]
****** Types <<Trace/Types>>
- _Relies on_
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
** test
*** Golden <<test/Golden>>
- _Relies on_
  + [[Library]]
*** Main <<StandardLibrary/test/Main>>
- _Relies on_
  + [[Library]]
  + [[Fetch]]
  + [[Library/Test/Golden]]
*** NameSymb
- _Relies on_
  + [[Library]]
  + [[NameSymbol]]
*** Pretty <<test/Pretty>>
- _Relies on_
  + [[Library]]
  + [[PrettyPrint]]
*** Trace <<test/Trace>>
- _Relies on_
  + [[Library]]
  + [[Library/Trace]]
  + [[Trace/Environment]]
* Test
** DataStructures
*** Setup <<DataStructures/Setup>>
*** src
**** Juvix
***** Test
****** Data
******* Context
******** ShowReferences
ShowReferences provides the Context a more readable Record
datastructure. Thus when one tries to show the Record Data structure
inside of =Context.Definition=, we don't get #<stm-map> but instead
the full symbol qualifying map.
- _Relies on_
  + [[NameSpace]]
  + [[Open]]
  + [[Context/Types]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
*** test
**** Spec <<DataStructures/test/Spec>>
- _Relies on_
  + [[Library]]
* Translate
** Setup <<Translate/Setup>>
** src
*** Juvix
**** FreeVars
TODO ∷ determine what has changed in the rebasing of this algo
- FreeVars is an algorithm that checks for free symbols in the AST.
- The =ExcludedSet= holds the symbols defined... These are needed
  in case of a degenerate case like
  #+BEGIN_SRC ocaml
    let foo =
      let type point = {x : int, y : int} in
      let our-point  = {x = 3, y = 4} in
      our-point.x + our-point.y
  #+END_SRC
  + here we need to dismiss =our-point.x= and =our-point.y=, just
    filtering out =our-point= isn't enough! we have to check if the
    first-part of the name has =our-point=, since everything shares
    the same namespace
- TODO :: How do we handle this case?
  #+BEGIN_SRC ocaml
    mod Foo where
    let foo (x :: xs) = x + TopLevel.Foo.foo xs
    let foo []        = 0
  #+END_SRC
  + To Handle this, we need to unqualify the foo, and have the
    module handle the symbol allocation
- NOTE :: we assume in =nameifyAdt= which takes effect in the =\\=
  call to =nameifyLetType=, that definitions of constructors before
  this point can't be redefined
  + This means that if we have ordered definitions, we'll silently
    drop the calls to the old constructors.
  + Thus, please redefine the logic there to support such modes
- _Reasons to update_
  1. let's not being recursive
     - we assume lets are recursive, if this changes the code
       has to be updated to account for that'
  2. Language becomes ordered
     - see first note above
  3. Universe or Declaration talk about free variables
     - currently universe is unfinished, and are not
       first class
|
- FreeVars is an algorithm that checks for free symbols in the AST.
- The =ExcludedSet= holds the symbols defined... These are needed
  in case of a degenerate case like
  #+BEGIN_SRC ocaml
    let foo =
      let type point = {x : int, y : int} in
      let our-point  = {x = 3, y = 4} in
      our-point.x + our-point.y
  #+END_SRC
  + here we need to dismiss =our-point.x= and =our-point.y=, just
- _Relies on_
  + [[Juvix/Closure]]
  + [[Contextify/Environment]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
**** Contextify <<Juvix/Contextify>>
- _Relies on_
  + [[Juvix/Context]]
  + [[Contextify/Environment]]
  + [[Contextify/Passes]]
  + [[ResolveOpenInfo]]
  + [[ToContext/Sexp]]
  + [[ToContext/Types]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
***** Environment <<Contextify/Environment>>
- _Relies on_
  + [[Juvix/Closure]]
  + [[Juvix/Context]]
  + [[NameSpace]]
  + [[Traversal]]
  + [[InfixPrecedence/ShuntYard]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
  + [[Lens]]
  + [[Structure/Parsing]]
  + [[Transition]]
***** Passes <<Contextify/Passes>>
- _Relies on_
  + [[Juvix/Closure]]
  + [[Juvix/Context]]
  + [[Contextify/Environment]]
  + [[InfixPrecedence/ShuntYard]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
  + [[CoreNamed]]
  + [[Structure/Helpers]]
  + [[Lens]]
  + [[Structure/Parsing]]
  + [[Transition]]
***** InfixPrecedence
****** ShuntYard <<InfixPrecedence/ShuntYard>>
- This implements the Shunt Yard algorithm for determining the
  precedence of operations
- _Relies on_
  + [[Library]]
***** ToContext
****** ResolveOpenInfo
- This module is responsible for adding the reverse open
  information to the context, along with the alias map of what
  symbols get qualified to what module
- This module accepts a list of =PreQualified= which talks
  about
  1. The explicit module itself
  2. Any opens this module does
  3. Any modules defined in this module as to have implicit imports
- Currently the most complicated part of this module is the resolve
  section that creates an =OpenMap=
  + This code is responsible for taking in all the opens and
    properly storing them fully qualified.
  + This has to try to open as much as possible as we could have
    =open Michelson= =open Prelude=, in which Michelson is inside
    of prelude so it can't be resolved right away. This way can
    lead to ambiguities if it does exist so one has to be a bit
    careful opening in this way!
- The other bits of code are stand alone algorithms for filling in
  the reverse map and the qualification from that point
  forward.... these are thankfully quite straight forward
- _Relies on_
  + [[Juvix/Context]]
  + [[NameSpace]]
  + [[Open]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
****** Sexp <<ToContext/Sexp>>
- _Relies on_
  + [[Juvix/Context]]
  + [[NameSpace]]
  + [[ToContext/Types]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
****** Types <<ToContext/Types>>
- _Relies on_
  + [[Juvix/Context]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
**** Core
***** Common
****** Context
******* Traverse
Calculate mutually-recursive groups of definitions.
- _Relies on_
  + [[Juvix/Context]]
  + [[NameSpace]]
  + [[Traverse/Types]]
  + [[FreeVars]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
******** Types <<Traverse/Types>>
- _Relies on_
  + [[Context/Types]]
  + [[Context/Types]]
  + [[Library]]
  + [[NameSymbol]]
**** Desugar
Desugar takes the frontend syntax and through the =desugar=
function, removes all extra parts of syntax that can be boiled down
to simple macro expansion (simplification of the frontend syntax
from the syntax alone with no extra information needed!)
- _Relies on_
  + [[Desugar/Passes]]
  + [[Library]]
  + [[Juvix/Sexp]]
***** Passes <<Desugar/Passes>>
Passes contains a list of passes on the frontend syntax that can be
done with no extra information needed. Thus we export the following passes
- Removing Explicit Module declarations
- Removing Guards
- Conds ⟶ If ⟶ Match
- Combining signatures to functions
- Removing punned record arguments
- _Relies on_
  + [[Library]]
  + [[Juvix/Sexp]]
  + [[Lens]]
  + [[Structure/Parsing]]
  + [[Transition]]
**** Translate <<Juvix/Translate>>
- _Relies on_
  + [[Juvix/Contextify]]
  + [[Desugar]]
***** Pipeline <<Translate/Pipeline>>
- _Relies on_
  + [[TopLevel]]
****** TopLevel
- _Relies on_
  + [[Library]]
  + [[NameSymbol]]
  + [[Parsing/Types/Base]]
  + [[Juvix/Sexp]]
** test
*** Main <<Translate/test/Main>>
- _Relies on_
  + [[Library]]
*** Test
**** Contextify <<Test/Contextify>>
- _Relies on_
  + [[Juvix/Context]]
  + [[Juvix/Contextify]]
  + [[Contextify/Environment]]
  + [[ResolveOpenInfo]]
  + [[Library]]
  + [[Juvix/Sexp]]
**** Golden <<Translate/test/Test/Golden>>
- _Relies on_
  + [[Juvix/Context]]
  + [[Juvix/Contextify]]
  + [[Contextify/Environment]]
  + [[Contextify/Passes]]
  + [[Desugar/Passes]]
  + [[Library]]
  + [[Feedback]]
  + [[NameSymbol]]
  + [[Library/Parser]]
  + [[Library/Parser]]
  + [[Library/Test/Golden]]
  + [[Juvix/Parsing]]
  + [[Parsing/Parser]]
  + [[Parsing/Types]]
  + [[Parsing/Types/Base]]
  + [[Juvix/Sexp]]
  + [[ShowReferences]]
  + [[TopLevel]]
**** Context
***** Environment <<Context/Environment>>
- _Relies on_
  + [[Juvix/Closure]]
  + [[Juvix/Contextify]]
  + [[Contextify/Environment]]
  + [[Library]]
  + [[HashMap]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
***** Helpers <<Context/Helpers>>
- _Relies on_
  + [[Juvix/Context]]
  + [[Juvix/Contextify]]
  + [[ResolveOpenInfo]]
  + [[ToContext/Types]]
  + [[Desugar]]
  + [[Library]]
  + [[Parsing/Parser]]
  + [[Parsing/Types/Base]]
  + [[Juvix/Sexp]]
  + [[TopLevel]]
**** Contextualise
***** Contextify <<Contextualise/Contextify>>
- _Relies on_
  + [[Juvix/Context]]
  + [[Juvix/Contextify]]
  + [[Desugar]]
  + [[Library]]
  + [[Internal]]
  + [[Parsing/Parser]]
  + [[Parsing/Types]]
  + [[Juvix/Sexp]]
  + [[TopLevel]]
***** Infix
****** ShuntYard <<Infix/ShuntYard>>
- _Relies on_
  + [[InfixPrecedence/ShuntYard]]
  + [[Library]]
**** Desugar
***** Sexp <<Desugar/Sexp>>
- _Relies on_
  + [[Desugar]]
  + [[Desugar/Passes]]
  + [[Library]]
  + [[Parsing/Parser]]
  + [[Parsing/Types]]
  + [[Juvix/Sexp]]
  + [[TopLevel]]
**** Sexp
***** Helpers <<Sexp/Helpers>>
- _Relies on_
  + [[Juvix/Context]]
  + [[Juvix/Contextify]]
  + [[Desugar]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Parsing/Parser]]
  + [[Parsing/Types/Base]]
  + [[Juvix/Sexp]]
  + [[TopLevel]]
* Witch
** Setup <<Witch/Setup>>
** src
*** Juvix
**** Witch
***** CPSTranslation <<Witch/CPSTranslation>>
- _Relies on_
  + [[Juvix/Context]]
  + [[Library]]
  + [[Juvix/Sexp]]
  + [[Transform]]
****** SexpHelpers
- _Relies on_
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
  + [[Structure]]
  + [[CoreNamed]]
  + [[Structure/Parsing]]
  + [[Transition]]
****** Transform
- _Relies on_
  + [[Juvix/Context]]
  + [[NameSpace]]
  + [[Precedence]]
  + [[Library]]
  + [[NameSymbol]]
  + [[Juvix/Sexp]]
  + [[CoreNamed]]
  + [[Structure/Parsing]]
  + [[Transition]]
  + [[SexpHelpers]]
** test
*** CPSTranslation <<test/CPSTranslation>>
- _Relies on_
  + [[Desugar]]
  + [[Library]]
  + [[Parsing/Parser]]
  + [[Parsing/Types]]
  + [[Pipeline/ToSexp]]
  + [[Juvix/Sexp]]
  + [[Witch/CPSTranslation]]
*** Main <<Witch/test/Main>>
- _Relies on_
  + [[Library]]
